1、进程：系统进行资源分配和调度的一个独立单位。具有一定独立功能的程序关于某个数据集合上的一次运行活动。
         在Linux系统中，每个进程都有一个系统堆栈，保存中断现场信息和进程进入内核模式后执行子程序(函数)嵌套调用的返回现场信息。
   线程：进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.
         线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),
         但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
   关系：线程可以看成是进程中指令的不同执行路线。
         比如：在文字处理程序中，主线程负责用户的文字输入，而其他线程负责文字加工的一些任务。
        一个程序至少有一个进程,一个进程至少有一个线程
        默认情况下，一个线程的栈要预留1M的内存空间
        而一个进程中可用的内存空间只有2G，所以理论上一个进程中最多可以开2048个线程
        但是内存当然不可能完全拿来作线程的栈，所以实际数目要比这个值要小。
        你也可以通过连接时修改默认栈大小，将其改的比较小，这样就可以多开一些线程。
        如将默认栈的大小改成512K，这样理论上最多就可以开4096个线程。
        即使物理内存再大，一个进程中可以起的线程总要受到2GB这个内存空间的限制。
        比方说你的机器装了64GB物理内存，但每个进程的内存空间还是4GB，其中用户态可用的还是2GB。
        如果是同一台机器内的话，能起多少线程也是受内存限制的。每个线程对象都要站用非页面内存，而非页面内存也是有限的，当非页面内存被耗尽时，也就无法创建线程了。
        如果物理内存非常大，同一台机器内可以跑的线程数目的限制值会越来越大。
        在Windows下写个程序，一个进程Fork出2000个左右线程就会异常退出了，为什么？
        这个问题的产生是因为windows32位系统，一个进程所能使用的最大虚拟内存为2G，而一个线程的默认线程栈StackSize为1024K（1M），
        这样当线程数量逼近2000时，2000*1024K=2G(大约），内存资源就相当于耗尽。
   线程特点：
        线程创建与管理的开销小的多，因为线程可以共享父进程的所有程序和全局数据，
        这意味着创建一个新线程只涉及最小量的主存分配（线程表），也意味着一个进程创建的多个线程可以共享地址区域和数据。
        在进程内创建多线程，可以提高系统的并行处理能力。
   线程的状态变迁：
        线程是处理机调度的最小单位，而不是进程。一个进程可以创建一个线程，那么它具有单一的控制路径，一个进程也可以创建多个线程，那么它具有多个控制路径。
        这时，线程是争夺CPU的单位。
        线程的过程：创建，运行，等待，就绪或终止。
   进程的模式和类型：
        在Linux系统中，进程的执行模式分为：
        用户模式(用户进程，通常在用户模式中执行；通过系统调用或出现中断，异常进入内核模式)；
        内核模式(系统进程(只运行在内核模式),执行操作系统代码，完成一些管理性的工作，如内存分配和进程切换)。

   并行和并发:
        *		前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。
        *		后者是物理上同时发生，指在某一个时间点同时运行多个程序。
        *
   Java程序的运行原理：
        * 		由java命令启动JVM，JVM启动就相当于启动了一个进程。
        * 		接着有该进程创建了一个主线程去调用main方法。
        *
   jvm虚拟机的启动是单线程的还是多线程的?
        * 		多线程的。
        * 		原因是垃圾回收线程也要先启动，否则很容易会出现内存溢出。
        * 		现在的垃圾回收线程加上前面的主线程，最低启动了两个线程，所以，jvm的启动其实是多线程的。


    线程面试：    https://www.cnblogs.com/zjdxr-up/p/6638131.html